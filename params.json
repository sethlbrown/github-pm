{"name":"Managing Projects with GitHub","body":"![drupalcat](http://octodex.github.com/images/drupalcat.jpg)\r\n\r\nWe've tried a lot of project management systems over the years. In some way,\r\nthey have always seemed lacking, confusing or just a pain in the rear end. If\r\nthey had good tools for project managers, they were confusing to developers. If\r\nthey were useful for developers, designers complained about the eye-sores. No\r\none system ever seemed to satisfy the team.\r\n\r\nWe recently started using GitHub for project management after the developers\r\nstarted raving about how much they loved it for their code tools. To our\r\nsurprise, GitHub has a lot of very competent organizational tools that can\r\nbenefit any given project. Our designers even started using it for some of their\r\nown projects, which I think says something about GitHub's aesthetics. With a\r\nlittle bit of something for each role, GitHub is starting to come out on top as\r\nthe tool of choice for hosting code, managing projects, and greatly facilitating\r\nproject communication to boot!\r\n\r\nSome of the things I'd like to show you are not entirely dependent upon GitHub,\r\nbut are good practices in general. However, I'll be mostly talking about how we\r\nare doing these things within GitHub and how we're using GitHub's tools for\r\naccomplishing our project goals. So, whether or not you like GitHub as a tool\r\nfor your projects, I hope you will at least get something out of this.\r\n\r\n##Project Introductions\r\nGitHub is pretty developer-centric. As such, the first thing a developer sees\r\nwhen they open a project, is a view of the code repository. Below that, GitHub\r\nautomatically renders the README file found in the root of the code base. It's a\r\nvery typical practice for software projects, especially open source software\r\nprojects, to have this file in place. The README can be in various formats, but\r\na favorite of mine is [Markdown](http://daringfireball.net/projects/markdown/).\r\nSimply giving the README an extension of .md tells GitHub to render your\r\nREADME.md using the Markdown syntax. But even better, is that GitHub has it's\r\nown [flavor of markdown](http://github.github.com/github-flavored-markdown/).\r\nBeing that the developers of your project see the README first, this is a great\r\nplace for information that will get them up and running with the project as\r\nquickly as possible. Be concise. If you need to write more than a few sentences,\r\nchances are, you should be linking off to more in-depth documentation in your\r\nproject's wiki. Here's a quick guideline of some of the things that you might\r\nwant to include within your README.\r\n\r\n1. A quick project overview.\r\n\r\n    Give a few sentences of the project's goals and maybe a small bit of\r\n    background. Any links that you frequently access are also good to throw up\r\n    at the top as well, for easy access. Everyone loves easy access.\r\n\r\n1. Information about the directory structure.\r\n\r\n    Typically we have more than just Drupal in our repository root, so it's\r\n    helpful to have a brief description of what is in there. We typically have a\r\n    [drush folder](https://github.com/Lullabot/drupal-boilerplate/tree/master/drush)\r\n    for aliases and commands, as well as a patches directory with it's own README.\r\n\r\n1. How to get started developing.\r\n\r\n    Tell the developers what the best way to jump into the project might be.\r\n    Things like, \"clone this repo, create a feature branch, and send a pull\r\n    request for review. Whomever reviews the pull request should also do things\r\n    like remove the remote branch from the repository once it is merged.\"\r\n\r\n1. Development process.\r\n\r\n    It's a good idea to outline your development process, as it may change from\r\n    project to project. Do you want people to fork your repository and send pull\r\n    requests; create feature branches and send pull requests; or just go ahead\r\n    and commit to master? Let the developers know up-front, so there's no\r\n    confusion.\r\n\r\n1. Environments.\r\n\r\n    Outline information for your dev, staging and live environments, if you have\r\n    them. Also, outline the process for getting things to the various places.\r\n    How do I make sure my code is on staging? What is the best way to grab a\r\n    database dump? We like to setup drush aliases for each environment ahead of\r\n    time as a means of outlining this information and giving developers a good\r\n    starting point. Then document some example commands for doing some typical\r\n    operations. [Here's an example](https://github.com/Lullabot/drupal-boilerplate/blob/master/drush/aliases/example.aliases.drushrc.php).\r\n\r\n1. Links to where to find more information.\r\n\r\n    Typically this is our wiki, where we keep more detailed documentation and\r\n    notes on things; project details like the original proposal's SOW,\r\n    credentials to environments, Scrum Notes, Pre-launch checklists, etc.\r\n\r\nWe've attempted to create a [drupal-boilerplate](https://github.com/Lullabot/drupal-boilerplate),\r\nof sorts, for our Drupal projects which we're continuously re-using for new\r\nprojects and modifying when we find things that work better. Take a look, and if\r\nyou find it useful, please feel free to use it! If you find anything missing, or\r\nhave ideas on improving it, please fork it and send us a pull request!\r\n\r\n## Working with GitHub Issues\r\n\r\nGitHub has a pretty simple issue management system for bug tracking, but it is\r\nflexible enough to be a pretty powerful tool for managing entire projects, large\r\nand small. It has issues which can reference each-other; tags for attaching meta\r\ndata to your issues; methods for attaching code to your issues; and even\r\nmilestones for grouping and focusing your issues within time blocks.\r\n\r\n### Referencing and Association\r\n\r\nIssues can be associated with each other by simply throwing an #issue-number\r\n(ex: #3) within the body of another issue. This is useful in many ways. Firstly,\r\nit keeps the relationship simple. We don't have to worry about what kind of\r\nrelationship it is (parent/sibling/child) just that it's related. However, there\r\nare a couple of tricks that make this a little more useful if you understand how\r\nit works. Let me give you an example.\r\n\r\nLet's say you typically create an issue for a content type, and one of the\r\nfields on that content type is a taxonomy vocabulary. You probably want to break\r\nthat vocabulary creation out into it's own issue. So you create the issue for the\r\nnews content type\r\n![news-content-type](https://img.skitch.com/20120607-kday7nnj62xedpty25yxgmbd93.jpg)\r\n\r\nand then you create an issue for the taxonomy vocabulary and, within your\r\ndescription, link to the news issue.\r\n![tags-taxonomy](https://img.skitch.com/20120607-gah6niabiwa1ybae99rmccnii9.jpg)\r\n\r\nJust by putting in the #ticket-number (in this case #4) GitHub creates a link to\r\nthe news issue AND it places a back-link reference within the news issue to your\r\ntags issue!\r\n![news-tags](https://img.skitch.com/20120607-fkc64xhq47sq5ph7bj48d3ffnj.jpg)\r\n\r\nAs a part of this reference you will notice that it also gives you the status of\r\nthe referenced issue. Very handy for whomever is assigned this news issue. They\r\ncan easily see the status of it's 'dependency'. I use that term loosely because\r\nit is a dependency in this instance, but not always.\r\n\r\n### Issue Tags\r\n\r\nTags are a simple and effective way to add meta data to your issues. A lot of\r\nsystems tend to create fields and categories with various values in an effort to\r\nallow you finite control of the meta data for an issue. I've found the simple\r\ntagging system that GitHub employs to be very efficient and more flexible.\r\n\r\nGitHub comes with a few tags by default: bug, duplicate, enhancement, invalid,\r\nquestion, and won't fix. These give you a good idea of how to start using tags.\r\nFor example, \"bug\" is a type of issue, while \"won't fix\" is more of a status.\r\nTags can be anything, and if chosen wisely, can give any developer an immediate\r\nclue as to what sort of ticket it is, what section it might apply to, or what\r\nstatus it is in at a quick glance.\r\n\r\nWhile they're useful for developers, they're also good for the organizer of the\r\nproject in that they serve as a great filtering mechanism as well. For instance,\r\njust by selecting various tags, I can see all of the issues that are \"migration\"\r\nissues for \"taxonomy\", or \"content types\".\r\n![content-migration](https://img.skitch.com/20120607-kfqtrgq148ywk7xxp24fcy74wp.jpg)\r\n\r\n### Attach Code to an Existing Issue\r\n\r\nPull requests are an amazing tool for code collaboration. If you're new to the\r\nconcept, check out this [pull request demo](https://vimeo.com/41045197). It's a\r\nquick and easy way for developers to basically create a copy of the code base\r\n(by either forking or branching) and suggesting modifications to the existing\r\ncode, or contributing new code. It allows the other members of the project to\r\nthen review that code, make their own suggestions with in-line commenting, and\r\nthen make a decision as to whether to merge it into the main code base or not.\r\nWe've found the in-line commenting with pull requests to be immensely useful\r\nsince they keep everyone in the project in the loop with changes that are\r\nhappening.\r\n![code-comments](https://img.skitch.com/20120609-e6pfy9sts7nbi2p3kw4um1iikx.jpg)\r\n\r\nPull requests in general are a great means of peer review and have helped to\r\nkeep the quality of our code up to everyone's standards. There's a bit of\r\noverhead in that it may take a little longer for some new piece of code to be\r\nmerged in, so plan accordingly. But this also means we find bugs sooner,\r\ntypically before they're actually introduced into the system.\r\n\r\nOne of the gripes I had with pull requests, was that when you create one through\r\nGitHub's web interface, it basically creates a new issue. And though you can\r\ncertainly reference a particular issue within your pull request, it's still a\r\nseparate issue. However, through a nice command-line tool called [Hub](https://github.com/defunkt/hub),\r\nwe've found there is a way to [turn issues into pull requests](http://www.youtube.com/watch?v=suS3lDn20HY)!\r\nVery handy for keeping your discussions and code all in one place and not having\r\nto deal with multiple issues about the same thing.\r\n\r\n### Milestones\r\n\r\nGitHub has a mechanism for milestones that is actually quite typical of many\r\nproject systems these days. When you create a new milestone, it simply has a\r\ntitle, description, and a date choosing mechanism.\r\n![milestone](https://img.skitch.com/20120609-4nfhurufifhbxpic32j1ynt1b.jpg)\r\n\r\nYou can have a nice overview during the week that gives you the percentage of\r\ncompletion.\r\n![closed](https://img.skitch.com/20120609-1kcnp51njk55qqb71nfh5dssii.jpg)\r\n\r\nWe tend to only plan one sprint ahead, but there is a milestone created for each\r\nweek up until the end of the project. By seeing that there are 5 more sprints\r\nwithout issues, you can easily tell that there are 5 more weeks left until the\r\nend of the project.\r\n![open](https://img.skitch.com/20120609-fbaj8534tjhmt2t7jc661pquky.jpg)\r\n\r\nWe grab these tickets from the Backlog, which is essentially just any ticket\r\nthat is **not** in a Sprint.\r\n![backlog](https://img.skitch.com/20120609-tx4b1a2iebb1a7i1f5higsdrf.jpg)\r\n\r\n### Sprint Methodology\r\nMost agile scrum projects tend to go with two week sprints. I've recently found\r\nthat one week sprints are even better. With such a limited scope, it's much\r\neasier to keep track of things in your head, like what needs to be done, when it\r\nneeds to be done, and to keep the general goal of the week in mind at all times.\r\nIt also has the added benefit of making meetings shorter, and who doesn't want\r\nshorter meetings?!. Two week sprint reviews and sprint planning meetings are\r\nusually around 1 hour each, but with a more limited scope we've been able to\r\nkeep our sprint planning and review meetings to about half an hour total on\r\nFridays.\r\n\r\n## Huboard\r\n\r\nOne area in GitHub's issue tracking system I have found a bit lacking for\r\nproject management, is the lack of a mechanism for prioritizing your issues. You\r\ncould probably come up with tags for High, Medium and Low-priority, but I tend\r\nto prefer an ordered list with the highest priority things on top.\r\n\r\nEnter [Huboard](https://github.com/rauhryan/huboard), which gives you a nice\r\nKanban-style interface (similar to [Trello](https://trello.com/)) right on top\r\nof the GitHub api. You're looking at your GitHub issues, but with a different\r\ninterface. The instructions for setting this up are quite sufficient, so I'll\r\nnot re-iterate those, but I've found that it's quite easy and quick to setup on\r\n[Heroku](http://www.heroku.com/) with very little maintenance overhead. With\r\nHuboard, we now have a means of seeing what the priority tasks are for the week\r\nand it gives developers an easy way to see what they should work on next.\r\n![huboard](https://img.skitch.com/20120609-my9ug4h3us75y98g71tdbssfp9.jpg)\r\n\r\n---\r\nSo while GitHub does have many things we need to make a project successful,\r\nthere are a couple places it may be lacking slightly. However, the team over at\r\nGitHub is continually making improvements to their product and they [blog](https://github.com/blog/)\r\nabout it often.\r\n\r\nI also think that there is probably a better means of exposing some of the\r\ntypical project information for stakeholders and clients in a way they can\r\nunderstand. GitHub is great for the technically-minded person, but less\r\ntech-savvy people may not find it as attractive. I'm still working on ways to\r\nreport on progress to project stakeholders in a more visual way easy and when I\r\nfind one I like, I plan to update you all.\r\n\r\nIf you have any suggestions on things we might also do to improve our process,\r\nor would like to share with us some of the exciting things you're doing with\r\nyour own processes, please hit us up in the comments section! We'd love to hear\r\nfrom you! And remember, Lullabot loves you!","tagline":"Tips and tricks for project organizers.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}